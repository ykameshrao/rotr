// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rotr.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rotr_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rotr_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rotr_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rotr_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rotr_2eproto;
namespace rotr {
class AppendEntriesRequest;
class AppendEntriesRequestDefaultTypeInternal;
extern AppendEntriesRequestDefaultTypeInternal _AppendEntriesRequest_default_instance_;
class AppendEntriesRequest_EntriesEntry_DoNotUse;
class AppendEntriesRequest_EntriesEntry_DoNotUseDefaultTypeInternal;
extern AppendEntriesRequest_EntriesEntry_DoNotUseDefaultTypeInternal _AppendEntriesRequest_EntriesEntry_DoNotUse_default_instance_;
class AppendEntriesResponse;
class AppendEntriesResponseDefaultTypeInternal;
extern AppendEntriesResponseDefaultTypeInternal _AppendEntriesResponse_default_instance_;
class ClusterInfo;
class ClusterInfoDefaultTypeInternal;
extern ClusterInfoDefaultTypeInternal _ClusterInfo_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeInfoList;
class NodeInfoListDefaultTypeInternal;
extern NodeInfoListDefaultTypeInternal _NodeInfoList_default_instance_;
class RequestVoteRequest;
class RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
class RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace rotr
PROTOBUF_NAMESPACE_OPEN
template<> ::rotr::AppendEntriesRequest* Arena::CreateMaybeMessage<::rotr::AppendEntriesRequest>(Arena*);
template<> ::rotr::AppendEntriesRequest_EntriesEntry_DoNotUse* Arena::CreateMaybeMessage<::rotr::AppendEntriesRequest_EntriesEntry_DoNotUse>(Arena*);
template<> ::rotr::AppendEntriesResponse* Arena::CreateMaybeMessage<::rotr::AppendEntriesResponse>(Arena*);
template<> ::rotr::ClusterInfo* Arena::CreateMaybeMessage<::rotr::ClusterInfo>(Arena*);
template<> ::rotr::NodeInfo* Arena::CreateMaybeMessage<::rotr::NodeInfo>(Arena*);
template<> ::rotr::NodeInfoList* Arena::CreateMaybeMessage<::rotr::NodeInfoList>(Arena*);
template<> ::rotr::RequestVoteRequest* Arena::CreateMaybeMessage<::rotr::RequestVoteRequest>(Arena*);
template<> ::rotr::RequestVoteResponse* Arena::CreateMaybeMessage<::rotr::RequestVoteResponse>(Arena*);
template<> ::rotr::Status* Arena::CreateMaybeMessage<::rotr::Status>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rotr {

enum StatusCode : int {
  None = 0,
  Failure = 1,
  Success = 2,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StatusCode_IsValid(int value);
constexpr StatusCode StatusCode_MIN = None;
constexpr StatusCode StatusCode_MAX = Success;
constexpr int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusCode_descriptor();
template<typename T>
inline const std::string& StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusCode_descriptor(), enum_t_value);
}
inline bool StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
// ===================================================================

class Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .rotr.StatusCode statusCode = 1;
  void clear_statuscode();
  ::rotr::StatusCode statuscode() const;
  void set_statuscode(::rotr::StatusCode value);
  private:
  ::rotr::StatusCode _internal_statuscode() const;
  void _internal_set_statuscode(::rotr::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:rotr.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int statuscode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(nullptr);
  }

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpV4AddressFieldNumber = 1,
    kHostNameFieldNumber = 2,
    kClusterIdFieldNumber = 4,
    kClusterNameFieldNumber = 5,
    kIsLeaderFieldNumber = 3,
  };
  // string ipV4Address = 1;
  void clear_ipv4address();
  const std::string& ipv4address() const;
  void set_ipv4address(const std::string& value);
  void set_ipv4address(std::string&& value);
  void set_ipv4address(const char* value);
  void set_ipv4address(const char* value, size_t size);
  std::string* mutable_ipv4address();
  std::string* release_ipv4address();
  void set_allocated_ipv4address(std::string* ipv4address);
  private:
  const std::string& _internal_ipv4address() const;
  void _internal_set_ipv4address(const std::string& value);
  std::string* _internal_mutable_ipv4address();
  public:

  // string hostName = 2;
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string clusterId = 4;
  void clear_clusterid();
  const std::string& clusterid() const;
  void set_clusterid(const std::string& value);
  void set_clusterid(std::string&& value);
  void set_clusterid(const char* value);
  void set_clusterid(const char* value, size_t size);
  std::string* mutable_clusterid();
  std::string* release_clusterid();
  void set_allocated_clusterid(std::string* clusterid);
  private:
  const std::string& _internal_clusterid() const;
  void _internal_set_clusterid(const std::string& value);
  std::string* _internal_mutable_clusterid();
  public:

  // string clusterName = 5;
  void clear_clustername();
  const std::string& clustername() const;
  void set_clustername(const std::string& value);
  void set_clustername(std::string&& value);
  void set_clustername(const char* value);
  void set_clustername(const char* value, size_t size);
  std::string* mutable_clustername();
  std::string* release_clustername();
  void set_allocated_clustername(std::string* clustername);
  private:
  const std::string& _internal_clustername() const;
  void _internal_set_clustername(const std::string& value);
  std::string* _internal_mutable_clustername();
  public:

  // bool isLeader = 3;
  void clear_isleader();
  bool isleader() const;
  void set_isleader(bool value);
  private:
  bool _internal_isleader() const;
  void _internal_set_isleader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rotr.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv4address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clusterid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clustername_;
  bool isleader_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// -------------------------------------------------------------------

class ClusterInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.ClusterInfo) */ {
 public:
  inline ClusterInfo() : ClusterInfo(nullptr) {}
  virtual ~ClusterInfo();

  ClusterInfo(const ClusterInfo& from);
  ClusterInfo(ClusterInfo&& from) noexcept
    : ClusterInfo() {
    *this = ::std::move(from);
  }

  inline ClusterInfo& operator=(const ClusterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClusterInfo& operator=(ClusterInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClusterInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterInfo* internal_default_instance() {
    return reinterpret_cast<const ClusterInfo*>(
               &_ClusterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClusterInfo& a, ClusterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClusterInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClusterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClusterInfo* New() const final {
    return CreateMaybeMessage<ClusterInfo>(nullptr);
  }

  ClusterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClusterInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClusterInfo& from);
  void MergeFrom(const ClusterInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.ClusterInfo";
  }
  protected:
  explicit ClusterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 3,
    kClusterNameFieldNumber = 1,
    kClusterIdFieldNumber = 2,
    kLeaderFieldNumber = 5,
  };
  // repeated .rotr.NodeInfo nodes = 3;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::rotr::NodeInfo* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >*
      mutable_nodes();
  private:
  const ::rotr::NodeInfo& _internal_nodes(int index) const;
  ::rotr::NodeInfo* _internal_add_nodes();
  public:
  const ::rotr::NodeInfo& nodes(int index) const;
  ::rotr::NodeInfo* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >&
      nodes() const;

  // string clusterName = 1;
  void clear_clustername();
  const std::string& clustername() const;
  void set_clustername(const std::string& value);
  void set_clustername(std::string&& value);
  void set_clustername(const char* value);
  void set_clustername(const char* value, size_t size);
  std::string* mutable_clustername();
  std::string* release_clustername();
  void set_allocated_clustername(std::string* clustername);
  private:
  const std::string& _internal_clustername() const;
  void _internal_set_clustername(const std::string& value);
  std::string* _internal_mutable_clustername();
  public:

  // string clusterId = 2;
  void clear_clusterid();
  const std::string& clusterid() const;
  void set_clusterid(const std::string& value);
  void set_clusterid(std::string&& value);
  void set_clusterid(const char* value);
  void set_clusterid(const char* value, size_t size);
  std::string* mutable_clusterid();
  std::string* release_clusterid();
  void set_allocated_clusterid(std::string* clusterid);
  private:
  const std::string& _internal_clusterid() const;
  void _internal_set_clusterid(const std::string& value);
  std::string* _internal_mutable_clusterid();
  public:

  // .rotr.NodeInfo leader = 5;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const ::rotr::NodeInfo& leader() const;
  ::rotr::NodeInfo* release_leader();
  ::rotr::NodeInfo* mutable_leader();
  void set_allocated_leader(::rotr::NodeInfo* leader);
  private:
  const ::rotr::NodeInfo& _internal_leader() const;
  ::rotr::NodeInfo* _internal_mutable_leader();
  public:
  void unsafe_arena_set_allocated_leader(
      ::rotr::NodeInfo* leader);
  ::rotr::NodeInfo* unsafe_arena_release_leader();

  // @@protoc_insertion_point(class_scope:rotr.ClusterInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo > nodes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clustername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clusterid_;
  ::rotr::NodeInfo* leader_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.NodeInfoList) */ {
 public:
  inline NodeInfoList() : NodeInfoList(nullptr) {}
  virtual ~NodeInfoList();

  NodeInfoList(const NodeInfoList& from);
  NodeInfoList(NodeInfoList&& from) noexcept
    : NodeInfoList() {
    *this = ::std::move(from);
  }

  inline NodeInfoList& operator=(const NodeInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoList& operator=(NodeInfoList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfoList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfoList* internal_default_instance() {
    return reinterpret_cast<const NodeInfoList*>(
               &_NodeInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NodeInfoList& a, NodeInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfoList* New() const final {
    return CreateMaybeMessage<NodeInfoList>(nullptr);
  }

  NodeInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfoList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfoList& from);
  void MergeFrom(const NodeInfoList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.NodeInfoList";
  }
  protected:
  explicit NodeInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .rotr.NodeInfo nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::rotr::NodeInfo* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >*
      mutable_nodes();
  private:
  const ::rotr::NodeInfo& _internal_nodes(int index) const;
  ::rotr::NodeInfo* _internal_add_nodes();
  public:
  const ::rotr::NodeInfo& nodes(int index) const;
  ::rotr::NodeInfo* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:rotr.NodeInfoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo > nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesRequest_EntriesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AppendEntriesRequest_EntriesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AppendEntriesRequest_EntriesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  AppendEntriesRequest_EntriesEntry_DoNotUse();
  explicit AppendEntriesRequest_EntriesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AppendEntriesRequest_EntriesEntry_DoNotUse& other);
  static const AppendEntriesRequest_EntriesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AppendEntriesRequest_EntriesEntry_DoNotUse*>(&_AppendEntriesRequest_EntriesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "rotr.AppendEntriesRequest.EntriesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "rotr.AppendEntriesRequest.EntriesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class AppendEntriesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.AppendEntriesRequest) */ {
 public:
  inline AppendEntriesRequest() : AppendEntriesRequest(nullptr) {}
  virtual ~AppendEntriesRequest();

  AppendEntriesRequest(const AppendEntriesRequest& from);
  AppendEntriesRequest(AppendEntriesRequest&& from) noexcept
    : AppendEntriesRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntriesRequest& operator=(const AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesRequest& operator=(AppendEntriesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AppendEntriesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesRequest*>(
               &_AppendEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AppendEntriesRequest& a, AppendEntriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesRequest* New() const final {
    return CreateMaybeMessage<AppendEntriesRequest>(nullptr);
  }

  AppendEntriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntriesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AppendEntriesRequest& from);
  void MergeFrom(const AppendEntriesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.AppendEntriesRequest";
  }
  protected:
  explicit AppendEntriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 6,
    kLeaderNodeFieldNumber = 2,
    kTermFieldNumber = 1,
    kPrevLogIndexFieldNumber = 3,
    kPrevLogTermFieldNumber = 4,
    kLeaderCommitIndexFieldNumber = 5,
  };
  // map<string, string> entries = 6;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_entries();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_entries();

  // .rotr.NodeInfo leaderNode = 2;
  bool has_leadernode() const;
  private:
  bool _internal_has_leadernode() const;
  public:
  void clear_leadernode();
  const ::rotr::NodeInfo& leadernode() const;
  ::rotr::NodeInfo* release_leadernode();
  ::rotr::NodeInfo* mutable_leadernode();
  void set_allocated_leadernode(::rotr::NodeInfo* leadernode);
  private:
  const ::rotr::NodeInfo& _internal_leadernode() const;
  ::rotr::NodeInfo* _internal_mutable_leadernode();
  public:
  void unsafe_arena_set_allocated_leadernode(
      ::rotr::NodeInfo* leadernode);
  ::rotr::NodeInfo* unsafe_arena_release_leadernode();

  // uint32 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint32 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 prevLogIndex = 3;
  void clear_prevlogindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 prevlogindex() const;
  void set_prevlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_prevlogindex() const;
  void _internal_set_prevlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 prevLogTerm = 4;
  void clear_prevlogterm();
  ::PROTOBUF_NAMESPACE_ID::uint32 prevlogterm() const;
  void set_prevlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_prevlogterm() const;
  void _internal_set_prevlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 leaderCommitIndex = 5;
  void clear_leadercommitindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 leadercommitindex() const;
  void set_leadercommitindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leadercommitindex() const;
  void _internal_set_leadercommitindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:rotr.AppendEntriesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AppendEntriesRequest_EntriesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > entries_;
  ::rotr::NodeInfo* leadernode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 term_;
  ::PROTOBUF_NAMESPACE_ID::uint32 prevlogindex_;
  ::PROTOBUF_NAMESPACE_ID::uint32 prevlogterm_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leadercommitindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.RequestVoteRequest) */ {
 public:
  inline RequestVoteRequest() : RequestVoteRequest(nullptr) {}
  virtual ~RequestVoteRequest();

  RequestVoteRequest(const RequestVoteRequest& from);
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestVoteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteRequest* New() const final {
    return CreateMaybeMessage<RequestVoteRequest>(nullptr);
  }

  RequestVoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestVoteRequest& from);
  void MergeFrom(const RequestVoteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.RequestVoteRequest";
  }
  protected:
  explicit RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateNodeFieldNumber = 2,
    kTermFieldNumber = 1,
    kLastLogIndexFieldNumber = 3,
    kLastLogTermFieldNumber = 4,
  };
  // .rotr.NodeInfo candidateNode = 2;
  bool has_candidatenode() const;
  private:
  bool _internal_has_candidatenode() const;
  public:
  void clear_candidatenode();
  const ::rotr::NodeInfo& candidatenode() const;
  ::rotr::NodeInfo* release_candidatenode();
  ::rotr::NodeInfo* mutable_candidatenode();
  void set_allocated_candidatenode(::rotr::NodeInfo* candidatenode);
  private:
  const ::rotr::NodeInfo& _internal_candidatenode() const;
  ::rotr::NodeInfo* _internal_mutable_candidatenode();
  public:
  void unsafe_arena_set_allocated_candidatenode(
      ::rotr::NodeInfo* candidatenode);
  ::rotr::NodeInfo* unsafe_arena_release_candidatenode();

  // uint32 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint32 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 lastLogIndex = 3;
  void clear_lastlogindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 lastlogindex() const;
  void set_lastlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lastlogindex() const;
  void _internal_set_lastlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 lastLogTerm = 4;
  void clear_lastlogterm();
  ::PROTOBUF_NAMESPACE_ID::uint32 lastlogterm() const;
  void set_lastlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lastlogterm() const;
  void _internal_set_lastlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:rotr.RequestVoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rotr::NodeInfo* candidatenode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 term_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lastlogindex_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lastlogterm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.AppendEntriesResponse) */ {
 public:
  inline AppendEntriesResponse() : AppendEntriesResponse(nullptr) {}
  virtual ~AppendEntriesResponse();

  AppendEntriesResponse(const AppendEntriesResponse& from);
  AppendEntriesResponse(AppendEntriesResponse&& from) noexcept
    : AppendEntriesResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntriesResponse& operator=(const AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesResponse& operator=(AppendEntriesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AppendEntriesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesResponse*>(
               &_AppendEntriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AppendEntriesResponse& a, AppendEntriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesResponse* New() const final {
    return CreateMaybeMessage<AppendEntriesResponse>(nullptr);
  }

  AppendEntriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntriesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AppendEntriesResponse& from);
  void MergeFrom(const AppendEntriesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.AppendEntriesResponse";
  }
  protected:
  explicit AppendEntriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentTermFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // uint32 currentTerm = 1;
  void clear_currentterm();
  ::PROTOBUF_NAMESPACE_ID::uint32 currentterm() const;
  void set_currentterm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_currentterm() const;
  void _internal_set_currentterm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rotr.AppendEntriesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currentterm_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rotr.RequestVoteResponse) */ {
 public:
  inline RequestVoteResponse() : RequestVoteResponse(nullptr) {}
  virtual ~RequestVoteResponse();

  RequestVoteResponse(const RequestVoteResponse& from);
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestVoteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteResponse* New() const final {
    return CreateMaybeMessage<RequestVoteResponse>(nullptr);
  }

  RequestVoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestVoteResponse& from);
  void MergeFrom(const RequestVoteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rotr.RequestVoteResponse";
  }
  protected:
  explicit RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rotr_2eproto);
    return ::descriptor_table_rotr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kVoteGrantedFieldNumber = 2,
  };
  // uint32 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint32 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool voteGranted = 2;
  void clear_votegranted();
  bool votegranted() const;
  void set_votegranted(bool value);
  private:
  bool _internal_votegranted() const;
  void _internal_set_votegranted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rotr.RequestVoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 term_;
  bool votegranted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rotr_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Status

// .rotr.StatusCode statusCode = 1;
inline void Status::clear_statuscode() {
  statuscode_ = 0;
}
inline ::rotr::StatusCode Status::_internal_statuscode() const {
  return static_cast< ::rotr::StatusCode >(statuscode_);
}
inline ::rotr::StatusCode Status::statuscode() const {
  // @@protoc_insertion_point(field_get:rotr.Status.statusCode)
  return _internal_statuscode();
}
inline void Status::_internal_set_statuscode(::rotr::StatusCode value) {
  
  statuscode_ = value;
}
inline void Status::set_statuscode(::rotr::StatusCode value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:rotr.Status.statusCode)
}

// string message = 2;
inline void Status::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Status::message() const {
  // @@protoc_insertion_point(field_get:rotr.Status.message)
  return _internal_message();
}
inline void Status::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:rotr.Status.message)
}
inline std::string* Status::mutable_message() {
  // @@protoc_insertion_point(field_mutable:rotr.Status.message)
  return _internal_mutable_message();
}
inline const std::string& Status::_internal_message() const {
  return message_.Get();
}
inline void Status::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Status::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rotr.Status.message)
}
inline void Status::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rotr.Status.message)
}
inline void Status::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rotr.Status.message)
}
inline std::string* Status::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Status::release_message() {
  // @@protoc_insertion_point(field_release:rotr.Status.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Status::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rotr.Status.message)
}

// -------------------------------------------------------------------

// NodeInfo

// string ipV4Address = 1;
inline void NodeInfo::clear_ipv4address() {
  ipv4address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeInfo::ipv4address() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.ipV4Address)
  return _internal_ipv4address();
}
inline void NodeInfo::set_ipv4address(const std::string& value) {
  _internal_set_ipv4address(value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.ipV4Address)
}
inline std::string* NodeInfo::mutable_ipv4address() {
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.ipV4Address)
  return _internal_mutable_ipv4address();
}
inline const std::string& NodeInfo::_internal_ipv4address() const {
  return ipv4address_.Get();
}
inline void NodeInfo::_internal_set_ipv4address(const std::string& value) {
  
  ipv4address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeInfo::set_ipv4address(std::string&& value) {
  
  ipv4address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.ipV4Address)
}
inline void NodeInfo::set_ipv4address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ipv4address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.ipV4Address)
}
inline void NodeInfo::set_ipv4address(const char* value,
    size_t size) {
  
  ipv4address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.ipV4Address)
}
inline std::string* NodeInfo::_internal_mutable_ipv4address() {
  
  return ipv4address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeInfo::release_ipv4address() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.ipV4Address)
  return ipv4address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfo::set_allocated_ipv4address(std::string* ipv4address) {
  if (ipv4address != nullptr) {
    
  } else {
    
  }
  ipv4address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipv4address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.ipV4Address)
}

// string hostName = 2;
inline void NodeInfo::clear_hostname() {
  hostname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeInfo::hostname() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.hostName)
  return _internal_hostname();
}
inline void NodeInfo::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.hostName)
}
inline std::string* NodeInfo::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.hostName)
  return _internal_mutable_hostname();
}
inline const std::string& NodeInfo::_internal_hostname() const {
  return hostname_.Get();
}
inline void NodeInfo::_internal_set_hostname(const std::string& value) {
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeInfo::set_hostname(std::string&& value) {
  
  hostname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.hostName)
}
inline void NodeInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.hostName)
}
inline void NodeInfo::set_hostname(const char* value,
    size_t size) {
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.hostName)
}
inline std::string* NodeInfo::_internal_mutable_hostname() {
  
  return hostname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.hostName)
  return hostname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfo::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.hostName)
}

// bool isLeader = 3;
inline void NodeInfo::clear_isleader() {
  isleader_ = false;
}
inline bool NodeInfo::_internal_isleader() const {
  return isleader_;
}
inline bool NodeInfo::isleader() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.isLeader)
  return _internal_isleader();
}
inline void NodeInfo::_internal_set_isleader(bool value) {
  
  isleader_ = value;
}
inline void NodeInfo::set_isleader(bool value) {
  _internal_set_isleader(value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.isLeader)
}

// string clusterId = 4;
inline void NodeInfo::clear_clusterid() {
  clusterid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeInfo::clusterid() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.clusterId)
  return _internal_clusterid();
}
inline void NodeInfo::set_clusterid(const std::string& value) {
  _internal_set_clusterid(value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.clusterId)
}
inline std::string* NodeInfo::mutable_clusterid() {
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.clusterId)
  return _internal_mutable_clusterid();
}
inline const std::string& NodeInfo::_internal_clusterid() const {
  return clusterid_.Get();
}
inline void NodeInfo::_internal_set_clusterid(const std::string& value) {
  
  clusterid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeInfo::set_clusterid(std::string&& value) {
  
  clusterid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.clusterId)
}
inline void NodeInfo::set_clusterid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clusterid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.clusterId)
}
inline void NodeInfo::set_clusterid(const char* value,
    size_t size) {
  
  clusterid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.clusterId)
}
inline std::string* NodeInfo::_internal_mutable_clusterid() {
  
  return clusterid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeInfo::release_clusterid() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.clusterId)
  return clusterid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfo::set_allocated_clusterid(std::string* clusterid) {
  if (clusterid != nullptr) {
    
  } else {
    
  }
  clusterid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clusterid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.clusterId)
}

// string clusterName = 5;
inline void NodeInfo::clear_clustername() {
  clustername_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeInfo::clustername() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.clusterName)
  return _internal_clustername();
}
inline void NodeInfo::set_clustername(const std::string& value) {
  _internal_set_clustername(value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.clusterName)
}
inline std::string* NodeInfo::mutable_clustername() {
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.clusterName)
  return _internal_mutable_clustername();
}
inline const std::string& NodeInfo::_internal_clustername() const {
  return clustername_.Get();
}
inline void NodeInfo::_internal_set_clustername(const std::string& value) {
  
  clustername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeInfo::set_clustername(std::string&& value) {
  
  clustername_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.clusterName)
}
inline void NodeInfo::set_clustername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clustername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.clusterName)
}
inline void NodeInfo::set_clustername(const char* value,
    size_t size) {
  
  clustername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.clusterName)
}
inline std::string* NodeInfo::_internal_mutable_clustername() {
  
  return clustername_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeInfo::release_clustername() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.clusterName)
  return clustername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfo::set_allocated_clustername(std::string* clustername) {
  if (clustername != nullptr) {
    
  } else {
    
  }
  clustername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clustername,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.clusterName)
}

// -------------------------------------------------------------------

// ClusterInfo

// string clusterName = 1;
inline void ClusterInfo::clear_clustername() {
  clustername_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClusterInfo::clustername() const {
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.clusterName)
  return _internal_clustername();
}
inline void ClusterInfo::set_clustername(const std::string& value) {
  _internal_set_clustername(value);
  // @@protoc_insertion_point(field_set:rotr.ClusterInfo.clusterName)
}
inline std::string* ClusterInfo::mutable_clustername() {
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.clusterName)
  return _internal_mutable_clustername();
}
inline const std::string& ClusterInfo::_internal_clustername() const {
  return clustername_.Get();
}
inline void ClusterInfo::_internal_set_clustername(const std::string& value) {
  
  clustername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClusterInfo::set_clustername(std::string&& value) {
  
  clustername_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rotr.ClusterInfo.clusterName)
}
inline void ClusterInfo::set_clustername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clustername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rotr.ClusterInfo.clusterName)
}
inline void ClusterInfo::set_clustername(const char* value,
    size_t size) {
  
  clustername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rotr.ClusterInfo.clusterName)
}
inline std::string* ClusterInfo::_internal_mutable_clustername() {
  
  return clustername_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClusterInfo::release_clustername() {
  // @@protoc_insertion_point(field_release:rotr.ClusterInfo.clusterName)
  return clustername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClusterInfo::set_allocated_clustername(std::string* clustername) {
  if (clustername != nullptr) {
    
  } else {
    
  }
  clustername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clustername,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rotr.ClusterInfo.clusterName)
}

// string clusterId = 2;
inline void ClusterInfo::clear_clusterid() {
  clusterid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClusterInfo::clusterid() const {
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.clusterId)
  return _internal_clusterid();
}
inline void ClusterInfo::set_clusterid(const std::string& value) {
  _internal_set_clusterid(value);
  // @@protoc_insertion_point(field_set:rotr.ClusterInfo.clusterId)
}
inline std::string* ClusterInfo::mutable_clusterid() {
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.clusterId)
  return _internal_mutable_clusterid();
}
inline const std::string& ClusterInfo::_internal_clusterid() const {
  return clusterid_.Get();
}
inline void ClusterInfo::_internal_set_clusterid(const std::string& value) {
  
  clusterid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClusterInfo::set_clusterid(std::string&& value) {
  
  clusterid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rotr.ClusterInfo.clusterId)
}
inline void ClusterInfo::set_clusterid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clusterid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rotr.ClusterInfo.clusterId)
}
inline void ClusterInfo::set_clusterid(const char* value,
    size_t size) {
  
  clusterid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rotr.ClusterInfo.clusterId)
}
inline std::string* ClusterInfo::_internal_mutable_clusterid() {
  
  return clusterid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClusterInfo::release_clusterid() {
  // @@protoc_insertion_point(field_release:rotr.ClusterInfo.clusterId)
  return clusterid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClusterInfo::set_allocated_clusterid(std::string* clusterid) {
  if (clusterid != nullptr) {
    
  } else {
    
  }
  clusterid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clusterid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rotr.ClusterInfo.clusterId)
}

// repeated .rotr.NodeInfo nodes = 3;
inline int ClusterInfo::_internal_nodes_size() const {
  return nodes_.size();
}
inline int ClusterInfo::nodes_size() const {
  return _internal_nodes_size();
}
inline void ClusterInfo::clear_nodes() {
  nodes_.Clear();
}
inline ::rotr::NodeInfo* ClusterInfo::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >*
ClusterInfo::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:rotr.ClusterInfo.nodes)
  return &nodes_;
}
inline const ::rotr::NodeInfo& ClusterInfo::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::rotr::NodeInfo& ClusterInfo::nodes(int index) const {
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.nodes)
  return _internal_nodes(index);
}
inline ::rotr::NodeInfo* ClusterInfo::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::rotr::NodeInfo* ClusterInfo::add_nodes() {
  // @@protoc_insertion_point(field_add:rotr.ClusterInfo.nodes)
  return _internal_add_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >&
ClusterInfo::nodes() const {
  // @@protoc_insertion_point(field_list:rotr.ClusterInfo.nodes)
  return nodes_;
}

// .rotr.NodeInfo leader = 5;
inline bool ClusterInfo::_internal_has_leader() const {
  return this != internal_default_instance() && leader_ != nullptr;
}
inline bool ClusterInfo::has_leader() const {
  return _internal_has_leader();
}
inline void ClusterInfo::clear_leader() {
  if (GetArena() == nullptr && leader_ != nullptr) {
    delete leader_;
  }
  leader_ = nullptr;
}
inline const ::rotr::NodeInfo& ClusterInfo::_internal_leader() const {
  const ::rotr::NodeInfo* p = leader_;
  return p != nullptr ? *p : *reinterpret_cast<const ::rotr::NodeInfo*>(
      &::rotr::_NodeInfo_default_instance_);
}
inline const ::rotr::NodeInfo& ClusterInfo::leader() const {
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.leader)
  return _internal_leader();
}
inline void ClusterInfo::unsafe_arena_set_allocated_leader(
    ::rotr::NodeInfo* leader) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_);
  }
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rotr.ClusterInfo.leader)
}
inline ::rotr::NodeInfo* ClusterInfo::release_leader() {
  
  ::rotr::NodeInfo* temp = leader_;
  leader_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::rotr::NodeInfo* ClusterInfo::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_release:rotr.ClusterInfo.leader)
  
  ::rotr::NodeInfo* temp = leader_;
  leader_ = nullptr;
  return temp;
}
inline ::rotr::NodeInfo* ClusterInfo::_internal_mutable_leader() {
  
  if (leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::rotr::NodeInfo>(GetArena());
    leader_ = p;
  }
  return leader_;
}
inline ::rotr::NodeInfo* ClusterInfo::mutable_leader() {
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.leader)
  return _internal_mutable_leader();
}
inline void ClusterInfo::set_allocated_leader(::rotr::NodeInfo* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete leader_;
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(leader);
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:rotr.ClusterInfo.leader)
}

// -------------------------------------------------------------------

// NodeInfoList

// repeated .rotr.NodeInfo nodes = 1;
inline int NodeInfoList::_internal_nodes_size() const {
  return nodes_.size();
}
inline int NodeInfoList::nodes_size() const {
  return _internal_nodes_size();
}
inline void NodeInfoList::clear_nodes() {
  nodes_.Clear();
}
inline ::rotr::NodeInfo* NodeInfoList::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfoList.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >*
NodeInfoList::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:rotr.NodeInfoList.nodes)
  return &nodes_;
}
inline const ::rotr::NodeInfo& NodeInfoList::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::rotr::NodeInfo& NodeInfoList::nodes(int index) const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfoList.nodes)
  return _internal_nodes(index);
}
inline ::rotr::NodeInfo* NodeInfoList::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::rotr::NodeInfo* NodeInfoList::add_nodes() {
  // @@protoc_insertion_point(field_add:rotr.NodeInfoList.nodes)
  return _internal_add_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rotr::NodeInfo >&
NodeInfoList::nodes() const {
  // @@protoc_insertion_point(field_list:rotr.NodeInfoList.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AppendEntriesRequest

// uint32 term = 1;
inline void AppendEntriesRequest::clear_term() {
  term_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::term() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.term)
  return _internal_term();
}
inline void AppendEntriesRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  term_ = value;
}
inline void AppendEntriesRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.term)
}

// .rotr.NodeInfo leaderNode = 2;
inline bool AppendEntriesRequest::_internal_has_leadernode() const {
  return this != internal_default_instance() && leadernode_ != nullptr;
}
inline bool AppendEntriesRequest::has_leadernode() const {
  return _internal_has_leadernode();
}
inline void AppendEntriesRequest::clear_leadernode() {
  if (GetArena() == nullptr && leadernode_ != nullptr) {
    delete leadernode_;
  }
  leadernode_ = nullptr;
}
inline const ::rotr::NodeInfo& AppendEntriesRequest::_internal_leadernode() const {
  const ::rotr::NodeInfo* p = leadernode_;
  return p != nullptr ? *p : *reinterpret_cast<const ::rotr::NodeInfo*>(
      &::rotr::_NodeInfo_default_instance_);
}
inline const ::rotr::NodeInfo& AppendEntriesRequest::leadernode() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.leaderNode)
  return _internal_leadernode();
}
inline void AppendEntriesRequest::unsafe_arena_set_allocated_leadernode(
    ::rotr::NodeInfo* leadernode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leadernode_);
  }
  leadernode_ = leadernode;
  if (leadernode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rotr.AppendEntriesRequest.leaderNode)
}
inline ::rotr::NodeInfo* AppendEntriesRequest::release_leadernode() {
  
  ::rotr::NodeInfo* temp = leadernode_;
  leadernode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::rotr::NodeInfo* AppendEntriesRequest::unsafe_arena_release_leadernode() {
  // @@protoc_insertion_point(field_release:rotr.AppendEntriesRequest.leaderNode)
  
  ::rotr::NodeInfo* temp = leadernode_;
  leadernode_ = nullptr;
  return temp;
}
inline ::rotr::NodeInfo* AppendEntriesRequest::_internal_mutable_leadernode() {
  
  if (leadernode_ == nullptr) {
    auto* p = CreateMaybeMessage<::rotr::NodeInfo>(GetArena());
    leadernode_ = p;
  }
  return leadernode_;
}
inline ::rotr::NodeInfo* AppendEntriesRequest::mutable_leadernode() {
  // @@protoc_insertion_point(field_mutable:rotr.AppendEntriesRequest.leaderNode)
  return _internal_mutable_leadernode();
}
inline void AppendEntriesRequest::set_allocated_leadernode(::rotr::NodeInfo* leadernode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete leadernode_;
  }
  if (leadernode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(leadernode);
    if (message_arena != submessage_arena) {
      leadernode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leadernode, submessage_arena);
    }
    
  } else {
    
  }
  leadernode_ = leadernode;
  // @@protoc_insertion_point(field_set_allocated:rotr.AppendEntriesRequest.leaderNode)
}

// uint32 prevLogIndex = 3;
inline void AppendEntriesRequest::clear_prevlogindex() {
  prevlogindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::_internal_prevlogindex() const {
  return prevlogindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::prevlogindex() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.prevLogIndex)
  return _internal_prevlogindex();
}
inline void AppendEntriesRequest::_internal_set_prevlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  prevlogindex_ = value;
}
inline void AppendEntriesRequest::set_prevlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_prevlogindex(value);
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.prevLogIndex)
}

// uint32 prevLogTerm = 4;
inline void AppendEntriesRequest::clear_prevlogterm() {
  prevlogterm_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::_internal_prevlogterm() const {
  return prevlogterm_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::prevlogterm() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.prevLogTerm)
  return _internal_prevlogterm();
}
inline void AppendEntriesRequest::_internal_set_prevlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  prevlogterm_ = value;
}
inline void AppendEntriesRequest::set_prevlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_prevlogterm(value);
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.prevLogTerm)
}

// uint32 leaderCommitIndex = 5;
inline void AppendEntriesRequest::clear_leadercommitindex() {
  leadercommitindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::_internal_leadercommitindex() const {
  return leadercommitindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesRequest::leadercommitindex() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.leaderCommitIndex)
  return _internal_leadercommitindex();
}
inline void AppendEntriesRequest::_internal_set_leadercommitindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  leadercommitindex_ = value;
}
inline void AppendEntriesRequest::set_leadercommitindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leadercommitindex(value);
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.leaderCommitIndex)
}

// map<string, string> entries = 6;
inline int AppendEntriesRequest::_internal_entries_size() const {
  return entries_.size();
}
inline int AppendEntriesRequest::entries_size() const {
  return _internal_entries_size();
}
inline void AppendEntriesRequest::clear_entries() {
  entries_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AppendEntriesRequest::_internal_entries() const {
  return entries_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AppendEntriesRequest::entries() const {
  // @@protoc_insertion_point(field_map:rotr.AppendEntriesRequest.entries)
  return _internal_entries();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AppendEntriesRequest::_internal_mutable_entries() {
  return entries_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AppendEntriesRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_map:rotr.AppendEntriesRequest.entries)
  return _internal_mutable_entries();
}

// -------------------------------------------------------------------

// RequestVoteRequest

// uint32 term = 1;
inline void RequestVoteRequest::clear_term() {
  term_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.term)
  return _internal_term();
}
inline void RequestVoteRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  term_ = value;
}
inline void RequestVoteRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:rotr.RequestVoteRequest.term)
}

// .rotr.NodeInfo candidateNode = 2;
inline bool RequestVoteRequest::_internal_has_candidatenode() const {
  return this != internal_default_instance() && candidatenode_ != nullptr;
}
inline bool RequestVoteRequest::has_candidatenode() const {
  return _internal_has_candidatenode();
}
inline void RequestVoteRequest::clear_candidatenode() {
  if (GetArena() == nullptr && candidatenode_ != nullptr) {
    delete candidatenode_;
  }
  candidatenode_ = nullptr;
}
inline const ::rotr::NodeInfo& RequestVoteRequest::_internal_candidatenode() const {
  const ::rotr::NodeInfo* p = candidatenode_;
  return p != nullptr ? *p : *reinterpret_cast<const ::rotr::NodeInfo*>(
      &::rotr::_NodeInfo_default_instance_);
}
inline const ::rotr::NodeInfo& RequestVoteRequest::candidatenode() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.candidateNode)
  return _internal_candidatenode();
}
inline void RequestVoteRequest::unsafe_arena_set_allocated_candidatenode(
    ::rotr::NodeInfo* candidatenode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(candidatenode_);
  }
  candidatenode_ = candidatenode;
  if (candidatenode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rotr.RequestVoteRequest.candidateNode)
}
inline ::rotr::NodeInfo* RequestVoteRequest::release_candidatenode() {
  
  ::rotr::NodeInfo* temp = candidatenode_;
  candidatenode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::rotr::NodeInfo* RequestVoteRequest::unsafe_arena_release_candidatenode() {
  // @@protoc_insertion_point(field_release:rotr.RequestVoteRequest.candidateNode)
  
  ::rotr::NodeInfo* temp = candidatenode_;
  candidatenode_ = nullptr;
  return temp;
}
inline ::rotr::NodeInfo* RequestVoteRequest::_internal_mutable_candidatenode() {
  
  if (candidatenode_ == nullptr) {
    auto* p = CreateMaybeMessage<::rotr::NodeInfo>(GetArena());
    candidatenode_ = p;
  }
  return candidatenode_;
}
inline ::rotr::NodeInfo* RequestVoteRequest::mutable_candidatenode() {
  // @@protoc_insertion_point(field_mutable:rotr.RequestVoteRequest.candidateNode)
  return _internal_mutable_candidatenode();
}
inline void RequestVoteRequest::set_allocated_candidatenode(::rotr::NodeInfo* candidatenode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete candidatenode_;
  }
  if (candidatenode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(candidatenode);
    if (message_arena != submessage_arena) {
      candidatenode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candidatenode, submessage_arena);
    }
    
  } else {
    
  }
  candidatenode_ = candidatenode;
  // @@protoc_insertion_point(field_set_allocated:rotr.RequestVoteRequest.candidateNode)
}

// uint32 lastLogIndex = 3;
inline void RequestVoteRequest::clear_lastlogindex() {
  lastlogindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteRequest::_internal_lastlogindex() const {
  return lastlogindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteRequest::lastlogindex() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.lastLogIndex)
  return _internal_lastlogindex();
}
inline void RequestVoteRequest::_internal_set_lastlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lastlogindex_ = value;
}
inline void RequestVoteRequest::set_lastlogindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lastlogindex(value);
  // @@protoc_insertion_point(field_set:rotr.RequestVoteRequest.lastLogIndex)
}

// uint32 lastLogTerm = 4;
inline void RequestVoteRequest::clear_lastlogterm() {
  lastlogterm_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteRequest::_internal_lastlogterm() const {
  return lastlogterm_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteRequest::lastlogterm() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.lastLogTerm)
  return _internal_lastlogterm();
}
inline void RequestVoteRequest::_internal_set_lastlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lastlogterm_ = value;
}
inline void RequestVoteRequest::set_lastlogterm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lastlogterm(value);
  // @@protoc_insertion_point(field_set:rotr.RequestVoteRequest.lastLogTerm)
}

// -------------------------------------------------------------------

// AppendEntriesResponse

// uint32 currentTerm = 1;
inline void AppendEntriesResponse::clear_currentterm() {
  currentterm_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesResponse::_internal_currentterm() const {
  return currentterm_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppendEntriesResponse::currentterm() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesResponse.currentTerm)
  return _internal_currentterm();
}
inline void AppendEntriesResponse::_internal_set_currentterm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  currentterm_ = value;
}
inline void AppendEntriesResponse::set_currentterm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_currentterm(value);
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesResponse.currentTerm)
}

// bool success = 2;
inline void AppendEntriesResponse::clear_success() {
  success_ = false;
}
inline bool AppendEntriesResponse::_internal_success() const {
  return success_;
}
inline bool AppendEntriesResponse::success() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesResponse.success)
  return _internal_success();
}
inline void AppendEntriesResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AppendEntriesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesResponse.success)
}

// -------------------------------------------------------------------

// RequestVoteResponse

// uint32 term = 1;
inline void RequestVoteResponse::clear_term() {
  term_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteResponse::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteResponse.term)
  return _internal_term();
}
inline void RequestVoteResponse::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  term_ = value;
}
inline void RequestVoteResponse::set_term(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:rotr.RequestVoteResponse.term)
}

// bool voteGranted = 2;
inline void RequestVoteResponse::clear_votegranted() {
  votegranted_ = false;
}
inline bool RequestVoteResponse::_internal_votegranted() const {
  return votegranted_;
}
inline bool RequestVoteResponse::votegranted() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteResponse.voteGranted)
  return _internal_votegranted();
}
inline void RequestVoteResponse::_internal_set_votegranted(bool value) {
  
  votegranted_ = value;
}
inline void RequestVoteResponse::set_votegranted(bool value) {
  _internal_set_votegranted(value);
  // @@protoc_insertion_point(field_set:rotr.RequestVoteResponse.voteGranted)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rotr

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rotr::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rotr::StatusCode>() {
  return ::rotr::StatusCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rotr_2eproto
