// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rotr.proto

#ifndef PROTOBUF_INCLUDED_rotr_2eproto
#define PROTOBUF_INCLUDED_rotr_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_rotr_2eproto 

namespace protobuf_rotr_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_rotr_2eproto
namespace rotr {
class AppendEntriesRequest;
class AppendEntriesRequestDefaultTypeInternal;
extern AppendEntriesRequestDefaultTypeInternal _AppendEntriesRequest_default_instance_;
class AppendEntriesRequest_EntriesEntry_DoNotUse;
class AppendEntriesRequest_EntriesEntry_DoNotUseDefaultTypeInternal;
extern AppendEntriesRequest_EntriesEntry_DoNotUseDefaultTypeInternal _AppendEntriesRequest_EntriesEntry_DoNotUse_default_instance_;
class AppendEntriesResponse;
class AppendEntriesResponseDefaultTypeInternal;
extern AppendEntriesResponseDefaultTypeInternal _AppendEntriesResponse_default_instance_;
class ClusterInfo;
class ClusterInfoDefaultTypeInternal;
extern ClusterInfoDefaultTypeInternal _ClusterInfo_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeInfoList;
class NodeInfoListDefaultTypeInternal;
extern NodeInfoListDefaultTypeInternal _NodeInfoList_default_instance_;
class RequestVoteRequest;
class RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
class RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace rotr
namespace google {
namespace protobuf {
template<> ::rotr::AppendEntriesRequest* Arena::CreateMaybeMessage<::rotr::AppendEntriesRequest>(Arena*);
template<> ::rotr::AppendEntriesRequest_EntriesEntry_DoNotUse* Arena::CreateMaybeMessage<::rotr::AppendEntriesRequest_EntriesEntry_DoNotUse>(Arena*);
template<> ::rotr::AppendEntriesResponse* Arena::CreateMaybeMessage<::rotr::AppendEntriesResponse>(Arena*);
template<> ::rotr::ClusterInfo* Arena::CreateMaybeMessage<::rotr::ClusterInfo>(Arena*);
template<> ::rotr::NodeInfo* Arena::CreateMaybeMessage<::rotr::NodeInfo>(Arena*);
template<> ::rotr::NodeInfoList* Arena::CreateMaybeMessage<::rotr::NodeInfoList>(Arena*);
template<> ::rotr::RequestVoteRequest* Arena::CreateMaybeMessage<::rotr::RequestVoteRequest>(Arena*);
template<> ::rotr::RequestVoteResponse* Arena::CreateMaybeMessage<::rotr::RequestVoteResponse>(Arena*);
template<> ::rotr::Status* Arena::CreateMaybeMessage<::rotr::Status>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace rotr {

enum StatusCode {
  None = 0,
  Failure = 1,
  Success = 2,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StatusCode_IsValid(int value);
const StatusCode StatusCode_MIN = None;
const StatusCode StatusCode_MAX = Success;
const int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusCode_descriptor();
inline const ::std::string& StatusCode_Name(StatusCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusCode_descriptor(), value);
}
inline bool StatusCode_Parse(
    const ::std::string& name, StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
// ===================================================================

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(NULL);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .rotr.StatusCode statusCode = 1;
  void clear_statuscode();
  static const int kStatusCodeFieldNumber = 1;
  ::rotr::StatusCode statuscode() const;
  void set_statuscode(::rotr::StatusCode value);

  // @@protoc_insertion_point(class_scope:rotr.Status)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int statuscode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NodeInfo* other);
  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(NULL);
  }

  NodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ipV4Address = 1;
  void clear_ipv4address();
  static const int kIpV4AddressFieldNumber = 1;
  const ::std::string& ipv4address() const;
  void set_ipv4address(const ::std::string& value);
  #if LANG_CXX11
  void set_ipv4address(::std::string&& value);
  #endif
  void set_ipv4address(const char* value);
  void set_ipv4address(const char* value, size_t size);
  ::std::string* mutable_ipv4address();
  ::std::string* release_ipv4address();
  void set_allocated_ipv4address(::std::string* ipv4address);

  // string hostName = 2;
  void clear_hostname();
  static const int kHostNameFieldNumber = 2;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // string clusterId = 4;
  void clear_clusterid();
  static const int kClusterIdFieldNumber = 4;
  const ::std::string& clusterid() const;
  void set_clusterid(const ::std::string& value);
  #if LANG_CXX11
  void set_clusterid(::std::string&& value);
  #endif
  void set_clusterid(const char* value);
  void set_clusterid(const char* value, size_t size);
  ::std::string* mutable_clusterid();
  ::std::string* release_clusterid();
  void set_allocated_clusterid(::std::string* clusterid);

  // string clusterName = 5;
  void clear_clustername();
  static const int kClusterNameFieldNumber = 5;
  const ::std::string& clustername() const;
  void set_clustername(const ::std::string& value);
  #if LANG_CXX11
  void set_clustername(::std::string&& value);
  #endif
  void set_clustername(const char* value);
  void set_clustername(const char* value, size_t size);
  ::std::string* mutable_clustername();
  ::std::string* release_clustername();
  void set_allocated_clustername(::std::string* clustername);

  // bool isLeader = 3;
  void clear_isleader();
  static const int kIsLeaderFieldNumber = 3;
  bool isleader() const;
  void set_isleader(bool value);

  // @@protoc_insertion_point(class_scope:rotr.NodeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ipv4address_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr clusterid_;
  ::google::protobuf::internal::ArenaStringPtr clustername_;
  bool isleader_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClusterInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.ClusterInfo) */ {
 public:
  ClusterInfo();
  virtual ~ClusterInfo();

  ClusterInfo(const ClusterInfo& from);

  inline ClusterInfo& operator=(const ClusterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterInfo(ClusterInfo&& from) noexcept
    : ClusterInfo() {
    *this = ::std::move(from);
  }

  inline ClusterInfo& operator=(ClusterInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterInfo* internal_default_instance() {
    return reinterpret_cast<const ClusterInfo*>(
               &_ClusterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClusterInfo* other);
  friend void swap(ClusterInfo& a, ClusterInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterInfo* New() const final {
    return CreateMaybeMessage<ClusterInfo>(NULL);
  }

  ClusterInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClusterInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClusterInfo& from);
  void MergeFrom(const ClusterInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rotr.NodeInfo nodes = 3;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 3;
  ::rotr::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >*
      mutable_nodes();
  const ::rotr::NodeInfo& nodes(int index) const;
  ::rotr::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >&
      nodes() const;

  // string clusterName = 1;
  void clear_clustername();
  static const int kClusterNameFieldNumber = 1;
  const ::std::string& clustername() const;
  void set_clustername(const ::std::string& value);
  #if LANG_CXX11
  void set_clustername(::std::string&& value);
  #endif
  void set_clustername(const char* value);
  void set_clustername(const char* value, size_t size);
  ::std::string* mutable_clustername();
  ::std::string* release_clustername();
  void set_allocated_clustername(::std::string* clustername);

  // string clusterId = 2;
  void clear_clusterid();
  static const int kClusterIdFieldNumber = 2;
  const ::std::string& clusterid() const;
  void set_clusterid(const ::std::string& value);
  #if LANG_CXX11
  void set_clusterid(::std::string&& value);
  #endif
  void set_clusterid(const char* value);
  void set_clusterid(const char* value, size_t size);
  ::std::string* mutable_clusterid();
  ::std::string* release_clusterid();
  void set_allocated_clusterid(::std::string* clusterid);

  // .rotr.NodeInfo leader = 5;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 5;
  private:
  const ::rotr::NodeInfo& _internal_leader() const;
  public:
  const ::rotr::NodeInfo& leader() const;
  ::rotr::NodeInfo* release_leader();
  ::rotr::NodeInfo* mutable_leader();
  void set_allocated_leader(::rotr::NodeInfo* leader);

  // @@protoc_insertion_point(class_scope:rotr.ClusterInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo > nodes_;
  ::google::protobuf::internal::ArenaStringPtr clustername_;
  ::google::protobuf::internal::ArenaStringPtr clusterid_;
  ::rotr::NodeInfo* leader_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeInfoList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.NodeInfoList) */ {
 public:
  NodeInfoList();
  virtual ~NodeInfoList();

  NodeInfoList(const NodeInfoList& from);

  inline NodeInfoList& operator=(const NodeInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfoList(NodeInfoList&& from) noexcept
    : NodeInfoList() {
    *this = ::std::move(from);
  }

  inline NodeInfoList& operator=(NodeInfoList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfoList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfoList* internal_default_instance() {
    return reinterpret_cast<const NodeInfoList*>(
               &_NodeInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NodeInfoList* other);
  friend void swap(NodeInfoList& a, NodeInfoList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfoList* New() const final {
    return CreateMaybeMessage<NodeInfoList>(NULL);
  }

  NodeInfoList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfoList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeInfoList& from);
  void MergeFrom(const NodeInfoList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rotr.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::rotr::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >*
      mutable_nodes();
  const ::rotr::NodeInfo& nodes(int index) const;
  ::rotr::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:rotr.NodeInfoList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo > nodes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AppendEntriesRequest_EntriesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<AppendEntriesRequest_EntriesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<AppendEntriesRequest_EntriesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  AppendEntriesRequest_EntriesEntry_DoNotUse();
  AppendEntriesRequest_EntriesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const AppendEntriesRequest_EntriesEntry_DoNotUse& other);
  static const AppendEntriesRequest_EntriesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AppendEntriesRequest_EntriesEntry_DoNotUse*>(&_AppendEntriesRequest_EntriesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class AppendEntriesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.AppendEntriesRequest) */ {
 public:
  AppendEntriesRequest();
  virtual ~AppendEntriesRequest();

  AppendEntriesRequest(const AppendEntriesRequest& from);

  inline AppendEntriesRequest& operator=(const AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesRequest(AppendEntriesRequest&& from) noexcept
    : AppendEntriesRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntriesRequest& operator=(AppendEntriesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesRequest*>(
               &_AppendEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AppendEntriesRequest* other);
  friend void swap(AppendEntriesRequest& a, AppendEntriesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesRequest* New() const final {
    return CreateMaybeMessage<AppendEntriesRequest>(NULL);
  }

  AppendEntriesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntriesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AppendEntriesRequest& from);
  void MergeFrom(const AppendEntriesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> entries = 6;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      entries() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_entries();

  // .rotr.NodeInfo leaderNode = 2;
  bool has_leadernode() const;
  void clear_leadernode();
  static const int kLeaderNodeFieldNumber = 2;
  private:
  const ::rotr::NodeInfo& _internal_leadernode() const;
  public:
  const ::rotr::NodeInfo& leadernode() const;
  ::rotr::NodeInfo* release_leadernode();
  ::rotr::NodeInfo* mutable_leadernode();
  void set_allocated_leadernode(::rotr::NodeInfo* leadernode);

  // uint32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::uint32 term() const;
  void set_term(::google::protobuf::uint32 value);

  // uint32 prevLogIndex = 3;
  void clear_prevlogindex();
  static const int kPrevLogIndexFieldNumber = 3;
  ::google::protobuf::uint32 prevlogindex() const;
  void set_prevlogindex(::google::protobuf::uint32 value);

  // uint32 prevLogTerm = 4;
  void clear_prevlogterm();
  static const int kPrevLogTermFieldNumber = 4;
  ::google::protobuf::uint32 prevlogterm() const;
  void set_prevlogterm(::google::protobuf::uint32 value);

  // uint32 leaderCommitIndex = 5;
  void clear_leadercommitindex();
  static const int kLeaderCommitIndexFieldNumber = 5;
  ::google::protobuf::uint32 leadercommitindex() const;
  void set_leadercommitindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rotr.AppendEntriesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      AppendEntriesRequest_EntriesEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > entries_;
  ::rotr::NodeInfo* leadernode_;
  ::google::protobuf::uint32 term_;
  ::google::protobuf::uint32 prevlogindex_;
  ::google::protobuf::uint32 prevlogterm_;
  ::google::protobuf::uint32 leadercommitindex_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestVoteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.RequestVoteRequest) */ {
 public:
  RequestVoteRequest();
  virtual ~RequestVoteRequest();

  RequestVoteRequest(const RequestVoteRequest& from);

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RequestVoteRequest* other);
  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteRequest* New() const final {
    return CreateMaybeMessage<RequestVoteRequest>(NULL);
  }

  RequestVoteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestVoteRequest& from);
  void MergeFrom(const RequestVoteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rotr.NodeInfo candidateNode = 2;
  bool has_candidatenode() const;
  void clear_candidatenode();
  static const int kCandidateNodeFieldNumber = 2;
  private:
  const ::rotr::NodeInfo& _internal_candidatenode() const;
  public:
  const ::rotr::NodeInfo& candidatenode() const;
  ::rotr::NodeInfo* release_candidatenode();
  ::rotr::NodeInfo* mutable_candidatenode();
  void set_allocated_candidatenode(::rotr::NodeInfo* candidatenode);

  // uint32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::uint32 term() const;
  void set_term(::google::protobuf::uint32 value);

  // uint32 lastLogIndex = 3;
  void clear_lastlogindex();
  static const int kLastLogIndexFieldNumber = 3;
  ::google::protobuf::uint32 lastlogindex() const;
  void set_lastlogindex(::google::protobuf::uint32 value);

  // uint32 lastLogTerm = 4;
  void clear_lastlogterm();
  static const int kLastLogTermFieldNumber = 4;
  ::google::protobuf::uint32 lastlogterm() const;
  void set_lastlogterm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rotr.RequestVoteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rotr::NodeInfo* candidatenode_;
  ::google::protobuf::uint32 term_;
  ::google::protobuf::uint32 lastlogindex_;
  ::google::protobuf::uint32 lastlogterm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AppendEntriesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.AppendEntriesResponse) */ {
 public:
  AppendEntriesResponse();
  virtual ~AppendEntriesResponse();

  AppendEntriesResponse(const AppendEntriesResponse& from);

  inline AppendEntriesResponse& operator=(const AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesResponse(AppendEntriesResponse&& from) noexcept
    : AppendEntriesResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntriesResponse& operator=(AppendEntriesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesResponse*>(
               &_AppendEntriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AppendEntriesResponse* other);
  friend void swap(AppendEntriesResponse& a, AppendEntriesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesResponse* New() const final {
    return CreateMaybeMessage<AppendEntriesResponse>(NULL);
  }

  AppendEntriesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntriesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AppendEntriesResponse& from);
  void MergeFrom(const AppendEntriesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 currentTerm = 1;
  void clear_currentterm();
  static const int kCurrentTermFieldNumber = 1;
  ::google::protobuf::uint32 currentterm() const;
  void set_currentterm(::google::protobuf::uint32 value);

  // bool success = 2;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:rotr.AppendEntriesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 currentterm_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestVoteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rotr.RequestVoteResponse) */ {
 public:
  RequestVoteResponse();
  virtual ~RequestVoteResponse();

  RequestVoteResponse(const RequestVoteResponse& from);

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RequestVoteResponse* other);
  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteResponse* New() const final {
    return CreateMaybeMessage<RequestVoteResponse>(NULL);
  }

  RequestVoteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestVoteResponse& from);
  void MergeFrom(const RequestVoteResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::uint32 term() const;
  void set_term(::google::protobuf::uint32 value);

  // bool voteGranted = 2;
  void clear_votegranted();
  static const int kVoteGrantedFieldNumber = 2;
  bool votegranted() const;
  void set_votegranted(bool value);

  // @@protoc_insertion_point(class_scope:rotr.RequestVoteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 term_;
  bool votegranted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rotr_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Status

// .rotr.StatusCode statusCode = 1;
inline void Status::clear_statuscode() {
  statuscode_ = 0;
}
inline ::rotr::StatusCode Status::statuscode() const {
  // @@protoc_insertion_point(field_get:rotr.Status.statusCode)
  return static_cast< ::rotr::StatusCode >(statuscode_);
}
inline void Status::set_statuscode(::rotr::StatusCode value) {
  
  statuscode_ = value;
  // @@protoc_insertion_point(field_set:rotr.Status.statusCode)
}

// string message = 2;
inline void Status::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Status::message() const {
  // @@protoc_insertion_point(field_get:rotr.Status.message)
  return message_.GetNoArena();
}
inline void Status::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rotr.Status.message)
}
#if LANG_CXX11
inline void Status::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rotr.Status.message)
}
#endif
inline void Status::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rotr.Status.message)
}
inline void Status::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rotr.Status.message)
}
inline ::std::string* Status::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:rotr.Status.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Status::release_message() {
  // @@protoc_insertion_point(field_release:rotr.Status.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Status::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:rotr.Status.message)
}

// -------------------------------------------------------------------

// NodeInfo

// string ipV4Address = 1;
inline void NodeInfo::clear_ipv4address() {
  ipv4address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::ipv4address() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.ipV4Address)
  return ipv4address_.GetNoArena();
}
inline void NodeInfo::set_ipv4address(const ::std::string& value) {
  
  ipv4address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.ipV4Address)
}
#if LANG_CXX11
inline void NodeInfo::set_ipv4address(::std::string&& value) {
  
  ipv4address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.ipV4Address)
}
#endif
inline void NodeInfo::set_ipv4address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ipv4address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.ipV4Address)
}
inline void NodeInfo::set_ipv4address(const char* value, size_t size) {
  
  ipv4address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.ipV4Address)
}
inline ::std::string* NodeInfo::mutable_ipv4address() {
  
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.ipV4Address)
  return ipv4address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_ipv4address() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.ipV4Address)
  
  return ipv4address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_ipv4address(::std::string* ipv4address) {
  if (ipv4address != NULL) {
    
  } else {
    
  }
  ipv4address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipv4address);
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.ipV4Address)
}

// string hostName = 2;
inline void NodeInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::hostname() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.hostName)
  return hostname_.GetNoArena();
}
inline void NodeInfo::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.hostName)
}
#if LANG_CXX11
inline void NodeInfo::set_hostname(::std::string&& value) {
  
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.hostName)
}
#endif
inline void NodeInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.hostName)
}
inline void NodeInfo::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.hostName)
}
inline ::std::string* NodeInfo::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.hostName)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.hostName)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.hostName)
}

// bool isLeader = 3;
inline void NodeInfo::clear_isleader() {
  isleader_ = false;
}
inline bool NodeInfo::isleader() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.isLeader)
  return isleader_;
}
inline void NodeInfo::set_isleader(bool value) {
  
  isleader_ = value;
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.isLeader)
}

// string clusterId = 4;
inline void NodeInfo::clear_clusterid() {
  clusterid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::clusterid() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.clusterId)
  return clusterid_.GetNoArena();
}
inline void NodeInfo::set_clusterid(const ::std::string& value) {
  
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.clusterId)
}
#if LANG_CXX11
inline void NodeInfo::set_clusterid(::std::string&& value) {
  
  clusterid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.clusterId)
}
#endif
inline void NodeInfo::set_clusterid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.clusterId)
}
inline void NodeInfo::set_clusterid(const char* value, size_t size) {
  
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.clusterId)
}
inline ::std::string* NodeInfo::mutable_clusterid() {
  
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.clusterId)
  return clusterid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_clusterid() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.clusterId)
  
  return clusterid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_clusterid(::std::string* clusterid) {
  if (clusterid != NULL) {
    
  } else {
    
  }
  clusterid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clusterid);
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.clusterId)
}

// string clusterName = 5;
inline void NodeInfo::clear_clustername() {
  clustername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::clustername() const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfo.clusterName)
  return clustername_.GetNoArena();
}
inline void NodeInfo::set_clustername(const ::std::string& value) {
  
  clustername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rotr.NodeInfo.clusterName)
}
#if LANG_CXX11
inline void NodeInfo::set_clustername(::std::string&& value) {
  
  clustername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rotr.NodeInfo.clusterName)
}
#endif
inline void NodeInfo::set_clustername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clustername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rotr.NodeInfo.clusterName)
}
inline void NodeInfo::set_clustername(const char* value, size_t size) {
  
  clustername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rotr.NodeInfo.clusterName)
}
inline ::std::string* NodeInfo::mutable_clustername() {
  
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfo.clusterName)
  return clustername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_clustername() {
  // @@protoc_insertion_point(field_release:rotr.NodeInfo.clusterName)
  
  return clustername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_clustername(::std::string* clustername) {
  if (clustername != NULL) {
    
  } else {
    
  }
  clustername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clustername);
  // @@protoc_insertion_point(field_set_allocated:rotr.NodeInfo.clusterName)
}

// -------------------------------------------------------------------

// ClusterInfo

// string clusterName = 1;
inline void ClusterInfo::clear_clustername() {
  clustername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClusterInfo::clustername() const {
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.clusterName)
  return clustername_.GetNoArena();
}
inline void ClusterInfo::set_clustername(const ::std::string& value) {
  
  clustername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rotr.ClusterInfo.clusterName)
}
#if LANG_CXX11
inline void ClusterInfo::set_clustername(::std::string&& value) {
  
  clustername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rotr.ClusterInfo.clusterName)
}
#endif
inline void ClusterInfo::set_clustername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clustername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rotr.ClusterInfo.clusterName)
}
inline void ClusterInfo::set_clustername(const char* value, size_t size) {
  
  clustername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rotr.ClusterInfo.clusterName)
}
inline ::std::string* ClusterInfo::mutable_clustername() {
  
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.clusterName)
  return clustername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClusterInfo::release_clustername() {
  // @@protoc_insertion_point(field_release:rotr.ClusterInfo.clusterName)
  
  return clustername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClusterInfo::set_allocated_clustername(::std::string* clustername) {
  if (clustername != NULL) {
    
  } else {
    
  }
  clustername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clustername);
  // @@protoc_insertion_point(field_set_allocated:rotr.ClusterInfo.clusterName)
}

// string clusterId = 2;
inline void ClusterInfo::clear_clusterid() {
  clusterid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClusterInfo::clusterid() const {
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.clusterId)
  return clusterid_.GetNoArena();
}
inline void ClusterInfo::set_clusterid(const ::std::string& value) {
  
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rotr.ClusterInfo.clusterId)
}
#if LANG_CXX11
inline void ClusterInfo::set_clusterid(::std::string&& value) {
  
  clusterid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rotr.ClusterInfo.clusterId)
}
#endif
inline void ClusterInfo::set_clusterid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rotr.ClusterInfo.clusterId)
}
inline void ClusterInfo::set_clusterid(const char* value, size_t size) {
  
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rotr.ClusterInfo.clusterId)
}
inline ::std::string* ClusterInfo::mutable_clusterid() {
  
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.clusterId)
  return clusterid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClusterInfo::release_clusterid() {
  // @@protoc_insertion_point(field_release:rotr.ClusterInfo.clusterId)
  
  return clusterid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClusterInfo::set_allocated_clusterid(::std::string* clusterid) {
  if (clusterid != NULL) {
    
  } else {
    
  }
  clusterid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clusterid);
  // @@protoc_insertion_point(field_set_allocated:rotr.ClusterInfo.clusterId)
}

// repeated .rotr.NodeInfo nodes = 3;
inline int ClusterInfo::nodes_size() const {
  return nodes_.size();
}
inline void ClusterInfo::clear_nodes() {
  nodes_.Clear();
}
inline ::rotr::NodeInfo* ClusterInfo::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >*
ClusterInfo::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:rotr.ClusterInfo.nodes)
  return &nodes_;
}
inline const ::rotr::NodeInfo& ClusterInfo::nodes(int index) const {
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.nodes)
  return nodes_.Get(index);
}
inline ::rotr::NodeInfo* ClusterInfo::add_nodes() {
  // @@protoc_insertion_point(field_add:rotr.ClusterInfo.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >&
ClusterInfo::nodes() const {
  // @@protoc_insertion_point(field_list:rotr.ClusterInfo.nodes)
  return nodes_;
}

// .rotr.NodeInfo leader = 5;
inline bool ClusterInfo::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline void ClusterInfo::clear_leader() {
  if (GetArenaNoVirtual() == NULL && leader_ != NULL) {
    delete leader_;
  }
  leader_ = NULL;
}
inline const ::rotr::NodeInfo& ClusterInfo::_internal_leader() const {
  return *leader_;
}
inline const ::rotr::NodeInfo& ClusterInfo::leader() const {
  const ::rotr::NodeInfo* p = leader_;
  // @@protoc_insertion_point(field_get:rotr.ClusterInfo.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::rotr::NodeInfo*>(
      &::rotr::_NodeInfo_default_instance_);
}
inline ::rotr::NodeInfo* ClusterInfo::release_leader() {
  // @@protoc_insertion_point(field_release:rotr.ClusterInfo.leader)
  
  ::rotr::NodeInfo* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline ::rotr::NodeInfo* ClusterInfo::mutable_leader() {
  
  if (leader_ == NULL) {
    auto* p = CreateMaybeMessage<::rotr::NodeInfo>(GetArenaNoVirtual());
    leader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:rotr.ClusterInfo.leader)
  return leader_;
}
inline void ClusterInfo::set_allocated_leader(::rotr::NodeInfo* leader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leader_;
  }
  if (leader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:rotr.ClusterInfo.leader)
}

// -------------------------------------------------------------------

// NodeInfoList

// repeated .rotr.NodeInfo nodes = 1;
inline int NodeInfoList::nodes_size() const {
  return nodes_.size();
}
inline void NodeInfoList::clear_nodes() {
  nodes_.Clear();
}
inline ::rotr::NodeInfo* NodeInfoList::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:rotr.NodeInfoList.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >*
NodeInfoList::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:rotr.NodeInfoList.nodes)
  return &nodes_;
}
inline const ::rotr::NodeInfo& NodeInfoList::nodes(int index) const {
  // @@protoc_insertion_point(field_get:rotr.NodeInfoList.nodes)
  return nodes_.Get(index);
}
inline ::rotr::NodeInfo* NodeInfoList::add_nodes() {
  // @@protoc_insertion_point(field_add:rotr.NodeInfoList.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rotr::NodeInfo >&
NodeInfoList::nodes() const {
  // @@protoc_insertion_point(field_list:rotr.NodeInfoList.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AppendEntriesRequest

// uint32 term = 1;
inline void AppendEntriesRequest::clear_term() {
  term_ = 0u;
}
inline ::google::protobuf::uint32 AppendEntriesRequest::term() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.term)
  return term_;
}
inline void AppendEntriesRequest::set_term(::google::protobuf::uint32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.term)
}

// .rotr.NodeInfo leaderNode = 2;
inline bool AppendEntriesRequest::has_leadernode() const {
  return this != internal_default_instance() && leadernode_ != NULL;
}
inline void AppendEntriesRequest::clear_leadernode() {
  if (GetArenaNoVirtual() == NULL && leadernode_ != NULL) {
    delete leadernode_;
  }
  leadernode_ = NULL;
}
inline const ::rotr::NodeInfo& AppendEntriesRequest::_internal_leadernode() const {
  return *leadernode_;
}
inline const ::rotr::NodeInfo& AppendEntriesRequest::leadernode() const {
  const ::rotr::NodeInfo* p = leadernode_;
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.leaderNode)
  return p != NULL ? *p : *reinterpret_cast<const ::rotr::NodeInfo*>(
      &::rotr::_NodeInfo_default_instance_);
}
inline ::rotr::NodeInfo* AppendEntriesRequest::release_leadernode() {
  // @@protoc_insertion_point(field_release:rotr.AppendEntriesRequest.leaderNode)
  
  ::rotr::NodeInfo* temp = leadernode_;
  leadernode_ = NULL;
  return temp;
}
inline ::rotr::NodeInfo* AppendEntriesRequest::mutable_leadernode() {
  
  if (leadernode_ == NULL) {
    auto* p = CreateMaybeMessage<::rotr::NodeInfo>(GetArenaNoVirtual());
    leadernode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:rotr.AppendEntriesRequest.leaderNode)
  return leadernode_;
}
inline void AppendEntriesRequest::set_allocated_leadernode(::rotr::NodeInfo* leadernode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leadernode_;
  }
  if (leadernode) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leadernode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leadernode, submessage_arena);
    }
    
  } else {
    
  }
  leadernode_ = leadernode;
  // @@protoc_insertion_point(field_set_allocated:rotr.AppendEntriesRequest.leaderNode)
}

// uint32 prevLogIndex = 3;
inline void AppendEntriesRequest::clear_prevlogindex() {
  prevlogindex_ = 0u;
}
inline ::google::protobuf::uint32 AppendEntriesRequest::prevlogindex() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.prevLogIndex)
  return prevlogindex_;
}
inline void AppendEntriesRequest::set_prevlogindex(::google::protobuf::uint32 value) {
  
  prevlogindex_ = value;
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.prevLogIndex)
}

// uint32 prevLogTerm = 4;
inline void AppendEntriesRequest::clear_prevlogterm() {
  prevlogterm_ = 0u;
}
inline ::google::protobuf::uint32 AppendEntriesRequest::prevlogterm() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.prevLogTerm)
  return prevlogterm_;
}
inline void AppendEntriesRequest::set_prevlogterm(::google::protobuf::uint32 value) {
  
  prevlogterm_ = value;
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.prevLogTerm)
}

// uint32 leaderCommitIndex = 5;
inline void AppendEntriesRequest::clear_leadercommitindex() {
  leadercommitindex_ = 0u;
}
inline ::google::protobuf::uint32 AppendEntriesRequest::leadercommitindex() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesRequest.leaderCommitIndex)
  return leadercommitindex_;
}
inline void AppendEntriesRequest::set_leadercommitindex(::google::protobuf::uint32 value) {
  
  leadercommitindex_ = value;
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesRequest.leaderCommitIndex)
}

// map<string, string> entries = 6;
inline int AppendEntriesRequest::entries_size() const {
  return entries_.size();
}
inline void AppendEntriesRequest::clear_entries() {
  entries_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
AppendEntriesRequest::entries() const {
  // @@protoc_insertion_point(field_map:rotr.AppendEntriesRequest.entries)
  return entries_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
AppendEntriesRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_map:rotr.AppendEntriesRequest.entries)
  return entries_.MutableMap();
}

// -------------------------------------------------------------------

// RequestVoteRequest

// uint32 term = 1;
inline void RequestVoteRequest::clear_term() {
  term_ = 0u;
}
inline ::google::protobuf::uint32 RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.term)
  return term_;
}
inline void RequestVoteRequest::set_term(::google::protobuf::uint32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:rotr.RequestVoteRequest.term)
}

// .rotr.NodeInfo candidateNode = 2;
inline bool RequestVoteRequest::has_candidatenode() const {
  return this != internal_default_instance() && candidatenode_ != NULL;
}
inline void RequestVoteRequest::clear_candidatenode() {
  if (GetArenaNoVirtual() == NULL && candidatenode_ != NULL) {
    delete candidatenode_;
  }
  candidatenode_ = NULL;
}
inline const ::rotr::NodeInfo& RequestVoteRequest::_internal_candidatenode() const {
  return *candidatenode_;
}
inline const ::rotr::NodeInfo& RequestVoteRequest::candidatenode() const {
  const ::rotr::NodeInfo* p = candidatenode_;
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.candidateNode)
  return p != NULL ? *p : *reinterpret_cast<const ::rotr::NodeInfo*>(
      &::rotr::_NodeInfo_default_instance_);
}
inline ::rotr::NodeInfo* RequestVoteRequest::release_candidatenode() {
  // @@protoc_insertion_point(field_release:rotr.RequestVoteRequest.candidateNode)
  
  ::rotr::NodeInfo* temp = candidatenode_;
  candidatenode_ = NULL;
  return temp;
}
inline ::rotr::NodeInfo* RequestVoteRequest::mutable_candidatenode() {
  
  if (candidatenode_ == NULL) {
    auto* p = CreateMaybeMessage<::rotr::NodeInfo>(GetArenaNoVirtual());
    candidatenode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:rotr.RequestVoteRequest.candidateNode)
  return candidatenode_;
}
inline void RequestVoteRequest::set_allocated_candidatenode(::rotr::NodeInfo* candidatenode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete candidatenode_;
  }
  if (candidatenode) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      candidatenode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, candidatenode, submessage_arena);
    }
    
  } else {
    
  }
  candidatenode_ = candidatenode;
  // @@protoc_insertion_point(field_set_allocated:rotr.RequestVoteRequest.candidateNode)
}

// uint32 lastLogIndex = 3;
inline void RequestVoteRequest::clear_lastlogindex() {
  lastlogindex_ = 0u;
}
inline ::google::protobuf::uint32 RequestVoteRequest::lastlogindex() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.lastLogIndex)
  return lastlogindex_;
}
inline void RequestVoteRequest::set_lastlogindex(::google::protobuf::uint32 value) {
  
  lastlogindex_ = value;
  // @@protoc_insertion_point(field_set:rotr.RequestVoteRequest.lastLogIndex)
}

// uint32 lastLogTerm = 4;
inline void RequestVoteRequest::clear_lastlogterm() {
  lastlogterm_ = 0u;
}
inline ::google::protobuf::uint32 RequestVoteRequest::lastlogterm() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteRequest.lastLogTerm)
  return lastlogterm_;
}
inline void RequestVoteRequest::set_lastlogterm(::google::protobuf::uint32 value) {
  
  lastlogterm_ = value;
  // @@protoc_insertion_point(field_set:rotr.RequestVoteRequest.lastLogTerm)
}

// -------------------------------------------------------------------

// AppendEntriesResponse

// uint32 currentTerm = 1;
inline void AppendEntriesResponse::clear_currentterm() {
  currentterm_ = 0u;
}
inline ::google::protobuf::uint32 AppendEntriesResponse::currentterm() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesResponse.currentTerm)
  return currentterm_;
}
inline void AppendEntriesResponse::set_currentterm(::google::protobuf::uint32 value) {
  
  currentterm_ = value;
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesResponse.currentTerm)
}

// bool success = 2;
inline void AppendEntriesResponse::clear_success() {
  success_ = false;
}
inline bool AppendEntriesResponse::success() const {
  // @@protoc_insertion_point(field_get:rotr.AppendEntriesResponse.success)
  return success_;
}
inline void AppendEntriesResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:rotr.AppendEntriesResponse.success)
}

// -------------------------------------------------------------------

// RequestVoteResponse

// uint32 term = 1;
inline void RequestVoteResponse::clear_term() {
  term_ = 0u;
}
inline ::google::protobuf::uint32 RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteResponse.term)
  return term_;
}
inline void RequestVoteResponse::set_term(::google::protobuf::uint32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:rotr.RequestVoteResponse.term)
}

// bool voteGranted = 2;
inline void RequestVoteResponse::clear_votegranted() {
  votegranted_ = false;
}
inline bool RequestVoteResponse::votegranted() const {
  // @@protoc_insertion_point(field_get:rotr.RequestVoteResponse.voteGranted)
  return votegranted_;
}
inline void RequestVoteResponse::set_votegranted(bool value) {
  
  votegranted_ = value;
  // @@protoc_insertion_point(field_set:rotr.RequestVoteResponse.voteGranted)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rotr

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::rotr::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rotr::StatusCode>() {
  return ::rotr::StatusCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_rotr_2eproto
